
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>veroku.cluster_graph &#8212; veroku 0.0.14 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for veroku.cluster_graph</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A module for building and performing inference with cluster graphs</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Standard imports</span>
<span class="kn">import</span> <span class="nn">collections</span>

<span class="c1"># Third-party imports</span>
<span class="kn">import</span> <span class="nn">IPython</span>
<span class="kn">import</span> <span class="nn">graphviz</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.lines</span> <span class="kn">import</span> <span class="n">Line2D</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="c1"># Local imports</span>
<span class="kn">from</span> <span class="nn">veroku._cg_helpers._cluster</span> <span class="kn">import</span> <span class="n">Cluster</span>
<span class="kn">import</span> <span class="nn">veroku._cg_helpers._animation</span> <span class="k">as</span> <span class="nn">cg_animation</span>
<span class="kn">from</span> <span class="nn">veroku.factors._factor_utils</span> <span class="kn">import</span> <span class="n">get_subset_evidence</span>

<span class="c1"># TODO: Optimise _pass_message.</span>
<span class="c1"># TODO: Improve sepsets selection for less loopiness.</span>
<span class="c1"># TODO: Optimisation: messages from clusters that did not receive any new messages in the previous round, do not need</span>
<span class="c1">#  new messages calculated.</span>

<span class="c1"># pylint: disable=protected-access</span>

<span class="n">DEFAULT_FIG_SIZE</span> <span class="o">=</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_sort_almost_sorted</span><span class="p">(</span><span class="n">almost_sorted_deque</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sort a deque like that where only the first element is potentially unsorted and should probably be last and the rest</span>
<span class="sd">     of the deque is sorted in descending order.</span>

<span class="sd">    :param collections.deque almost_sorted_deque: The deque of size n, where the first n-1 elements are definitely</span>
<span class="sd">        sorted (in descending order) and where the last element is also probably in the correct place, but needs to be</span>
<span class="sd">        checked</span>
<span class="sd">    :param callable key: The key (function) to use for sorting.</span>
<span class="sd">    :return: The sorted (given that the conditions are met) deque.</span>
<span class="sd">    :rtype: collections.deque</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">key</span><span class="p">(</span><span class="n">almost_sorted_deque</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">(</span><span class="n">almost_sorted_deque</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">almost_sorted_deque</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">almost_sorted_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">key</span><span class="p">(</span><span class="n">almost_sorted_deque</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">key</span><span class="p">(</span><span class="n">almost_sorted_deque</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]):</span>
        <span class="k">return</span> <span class="n">almost_sorted_deque</span>
    <span class="n">almost_sorted_deque</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">almost_sorted_deque</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">almost_sorted_deque</span>


<span class="k">def</span> <span class="nf">_evidence_reduce_factors</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="n">evidence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Observe relevant evidence for each factor.</span>

<span class="sd">    :param factors: The factors to reduce with the (relevant) evidence.</span>
<span class="sd">    :type factors: Factor list</span>
<span class="sd">    :param dict evidence: The evidence (i.e {&#39;a&#39;:1.0, &#39;b&#39;:2.0})</span>
<span class="sd">    :return: The reduced factors.</span>
<span class="sd">    :rtype factors: Factor list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reduced_factors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">evidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vrs</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">get_subset_evidence</span><span class="p">(</span><span class="n">all_evidence_dict</span><span class="o">=</span><span class="n">evidence</span><span class="p">,</span> <span class="n">subset_vars</span><span class="o">=</span><span class="n">factor</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vrs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">vrs</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="n">reduced_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">reduced_factors</span>


<span class="k">def</span> <span class="nf">_absorb_subset_factors</span><span class="p">(</span><span class="n">factors</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Absorb any factors that has a scope that is a subset of another factor into such a factor.</span>

<span class="sd">    :param factors: The list of factors to check for subset factors.</span>
<span class="sd">    :type factors: Factor list</span>
<span class="sd">    :return: The (potentially reduced) list of factors.</span>
<span class="sd">    :rtype: Factor list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Simplify this, if possible.</span>
    <span class="n">factors_absorbtion_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">))}</span>
    <span class="n">final_graph_cluster_factors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># factors: possibly smaller list of factors after factors which have a scope that is a subset of another factor have</span>
    <span class="c1"># been absorbed by the larger one.</span>
    <span class="n">factor_processed_mask</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">factor_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">factors</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">factor_processed_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">factor_product</span> <span class="o">=</span> <span class="n">factor_i</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">factor_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">factors</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">factor_processed_mask</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">factor_j</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">set</span><span class="p">(</span><span class="n">factor_product</span><span class="o">.</span><span class="n">var_names</span><span class="p">):</span>
                        <span class="n">factor_product</span> <span class="o">=</span> <span class="n">factor_product</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">factor_j</span><span class="p">)</span>
                        <span class="n">factors_absorbtion_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                        <span class="n">factor_processed_mask</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">factor_processed_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">factor_processed_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">final_graph_cluster_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor_product</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">factor_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">factors</span><span class="p">):</span>  <span class="c1"># add remaining factors</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">factor_processed_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">factor_processed_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">final_graph_cluster_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor_i</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
        <span class="n">factor_processed_mask</span>
    <span class="p">),</span> <span class="s2">&quot;Error: Some factors where not included during variable subset processing.&quot;</span>
    <span class="k">return</span> <span class="n">final_graph_cluster_factors</span>


<div class="viewcode-block" id="ClusterGraph"><a class="viewcode-back" href="../../veroku.cluster_graph.html#veroku.cluster_graph.ClusterGraph">[docs]</a><span class="k">class</span> <span class="nc">ClusterGraph</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for building and performing inference with cluster graphs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># pylint: disable=too-many-instance-attributes</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factors</span><span class="p">,</span> <span class="n">evidence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">special_evidence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">disable_tqdm</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a Cluster graph from a list of factors.</span>

<span class="sd">        :param factors: The factors to construct the graph from</span>
<span class="sd">        :type factors: factor list</span>
<span class="sd">        :param dict evidence: evidence dictionary (mapping variable names to values) that should be used to reduce</span>
<span class="sd">            factors before building the cluster graph.  Example: {&#39;a&#39;: 2, &#39;b&#39;:1}</span>
<span class="sd">        :param dict special_evidence: evidence dictionary (mapping variable names to values) that should be used in the</span>
<span class="sd">            calculation of messages, and not to reduce factors. This allows factor approximations - such as the</span>
<span class="sd">            non-linear Gaussian to be iteratively refined. Example: {&#39;a&#39;: 2, &#39;b&#39;:1}</span>
<span class="sd">        :param bool disable_tqdm: Disable the tqdm progress bars used in graph construction and processing.</span>
<span class="sd">        :param bool verbose: Whether or not to output additional information messages during graph construction and</span>
<span class="sd">        processing.</span>
<span class="sd">        :param debug:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: see if evidence and special_evidence can be replaced by a single variable.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_messages_passed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disable_tqdm</span> <span class="o">=</span> <span class="n">disable_tqdm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sync_message_passing_max_distances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">special_evidence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">special_evidence</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">special_evidence</span> <span class="o">=</span> <span class="n">special_evidence</span>
        <span class="n">all_evidence_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">special_evidence</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">evidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">evidence_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">evidence</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">all_evidence_vars</span> <span class="o">=</span> <span class="n">all_evidence_vars</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">evidence_vars</span><span class="p">)</span>
        <span class="n">all_factors_copy</span> <span class="o">=</span> <span class="n">_evidence_reduce_factors</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="n">evidence</span><span class="p">)</span>
        <span class="n">final_graph_cluster_factors</span> <span class="o">=</span> <span class="n">_absorb_subset_factors</span><span class="p">(</span><span class="n">all_factors_copy</span><span class="p">)</span>

        <span class="n">clusters</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Cluster</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">cluster_name_prefix</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;c</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">#&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">final_graph_cluster_factors</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_non_rip_sepsets_dict</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="n">all_evidence_vars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span> <span class="o">=</span> <span class="n">clusters</span>

        <span class="c1"># Add special evidence to factors</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">:</span>
            <span class="n">cluster_special_evidence_vars</span><span class="p">,</span> <span class="n">cluster_special_evidence_values</span> <span class="o">=</span> <span class="n">get_subset_evidence</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">special_evidence</span><span class="p">,</span> <span class="n">cluster</span><span class="o">.</span><span class="n">var_names</span>
            <span class="p">)</span>
            <span class="n">cluster_special_evidence</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span><span class="n">cluster_special_evidence_vars</span><span class="p">,</span> <span class="n">cluster_special_evidence_values</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">cluster</span><span class="o">.</span><span class="n">add_special_evidence</span><span class="p">(</span><span class="n">cluster_special_evidence</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_graph</span><span class="p">()</span>

        <span class="c1"># TODO: consolidate these two, if possible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message_passing_animation_frames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">passed_messages</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_set_non_rip_sepsets_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">all_evidence_vars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the preliminary sepsets dict before the RIP property is enforced.</span>

<span class="sd">        :param clusters: The clusters for which the sepsets should be calculated.</span>
<span class="sd">        :param all_evidence_vars: The variables for which there is observed evidence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_non_rip_sepsets</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)),</span> <span class="n">disable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">disable_tqdm</span><span class="p">):</span>
            <span class="n">vars_i</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">var_names</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)):</span>
                <span class="n">vars_j</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">var_names</span>
                <span class="n">sepset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">vars_j</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">vars_i</span><span class="p">))</span> <span class="o">-</span> <span class="n">all_evidence_vars</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_non_rip_sepsets</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sepset</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_non_rip_sepsets</span><span class="p">[(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sepset</span>

    <span class="k">def</span> <span class="nf">_build_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the cluster sepsets, graphviz graph and animation graph (for message_passing visualisation).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check for non-unique cluster_ids (This should never be the case)</span>
        <span class="n">cluster_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">cluster</span><span class="o">.</span><span class="n">cluster_id</span> <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cluster_ids</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_ids</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Non-unique cluster ids: </span><span class="si">{</span><span class="n">cluster_ids</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_conditional_print</span><span class="p">(</span><span class="s2">&quot;Info: Building graph.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span> <span class="o">=</span> <span class="n">graphviz</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;png&quot;</span><span class="p">)</span>
        <span class="n">rip_sepsets_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_running_intersection_sepsets</span><span class="p">()</span>

        <span class="c1"># TODO: see why this is necessary, remove if not</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">)),</span> <span class="n">disable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">disable_tqdm</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">remove_all_neighbours</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_conditional_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Debug: number of clusters: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">)),</span> <span class="n">disable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">disable_tqdm</span><span class="p">):</span>

            <span class="n">node_i_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_cluster_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">node</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">node_i_name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">node_i_name</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s2">&quot;filled&quot;</span><span class="p">,</span> <span class="n">fillcolor</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">)):</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">rip_sepsets_dict</span><span class="p">:</span>
                    <span class="n">sepset</span> <span class="o">=</span> <span class="n">rip_sepsets_dict</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sepset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Error: empty sepset&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add_neighbour</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">sepset</span><span class="o">=</span><span class="n">sepset</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">add_neighbour</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sepset</span><span class="o">=</span><span class="n">sepset</span><span class="p">)</span>

                    <span class="n">gmp_ij</span> <span class="o">=</span> <span class="n">_GraphMessagePath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">gmp_ji</span> <span class="o">=</span> <span class="n">_GraphMessagePath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gmp_ij</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gmp_ji</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add_outward_message_path</span><span class="p">(</span><span class="n">gmp_ij</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">add_outward_message_path</span><span class="p">(</span><span class="n">gmp_ji</span><span class="p">)</span>

                    <span class="c1"># Graph animation</span>
                    <span class="n">node_j_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">_cluster_id</span>
                    <span class="n">sepset_node_label</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sepset</span><span class="p">)</span>
                    <span class="n">sepset_node_name</span> <span class="o">=</span> <span class="n">cg_animation</span><span class="o">.</span><span class="n">make_sepset_node_name</span><span class="p">(</span><span class="n">node_i_name</span><span class="p">,</span> <span class="n">node_j_name</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">sepset_node_name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">sepset_node_label</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="s2">&quot;rectangle&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">node_i_name</span><span class="p">,</span> <span class="n">sepset_node_name</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">penwidth</span><span class="o">=</span><span class="s2">&quot;2.0&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">sepset_node_name</span><span class="p">,</span> <span class="n">node_j_name</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">penwidth</span><span class="o">=</span><span class="s2">&quot;2.0&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conditional_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;num graph message paths: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_conditional_print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print message if verbose is True.</span>

<span class="sd">        :param message: The message to print.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<div class="viewcode-block" id="ClusterGraph.plot_next_messages_info_gain"><a class="viewcode-back" href="../../veroku.cluster_graph.html#veroku.cluster_graph.ClusterGraph.plot_next_messages_info_gain">[docs]</a>    <span class="k">def</span> <span class="nf">plot_next_messages_info_gain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">legend_on</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the information gained by a receiving new messages over sebsequent iterations for all message paths in the</span>
<span class="sd">            graph.</span>

<span class="sd">        :param bool legend_on: Whether or not to show the message paths (specified by connected cluster pairs) in the</span>
<span class="sd">            plot legend.</span>
<span class="sd">        :param list figsize: The matplotlib figure size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">figsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">figsize</span> <span class="o">=</span> <span class="n">DEFAULT_FIG_SIZE</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">all_paths_information_gains_with_iters</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">gmp</span><span class="o">.</span><span class="n">information_gains_with_iters</span> <span class="k">for</span> <span class="n">gmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">paths_information_gains_with_iters</span> <span class="ow">in</span> <span class="n">all_paths_information_gains_with_iters</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">paths_information_gains_with_iters</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Information Gain of Messages along Graph Message Paths&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;iteration&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;D_KL(prev_msg||msg)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">legend_on</span><span class="p">:</span>
            <span class="n">legend</span> <span class="o">=</span> <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gmp</span><span class="o">.</span><span class="n">sender_cluster</span><span class="o">.</span><span class="n">cluster_id</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">gmp</span><span class="o">.</span><span class="n">receiver_cluster</span><span class="o">.</span><span class="n">cluster_id</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">gmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span>
            <span class="p">]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legend</span><span class="p">)</span></div>

<div class="viewcode-block" id="ClusterGraph.plot_message_convergence"><a class="viewcode-back" href="../../veroku.cluster_graph.html#veroku.cluster_graph.ClusterGraph.plot_message_convergence">[docs]</a>    <span class="k">def</span> <span class="nf">plot_message_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the the KL-divergence between the messages and their previous instances to indicate the message passing</span>
<span class="sd">        convergence.</span>

<span class="sd">        :param bool log: If True, plot the log of the KL-divergence.</span>
<span class="sd">        :param list figsize: The matplotlib [width, height] of the figure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">figsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">figsize</span> <span class="o">=</span> <span class="n">DEFAULT_FIG_SIZE</span>
        <span class="n">mp_max_dists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_message_passing_max_distances</span>
        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">mp_max_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mp_max_dists</span><span class="p">)</span>

        <span class="c1"># here we tile an flatten to prevent the plot omission of values with inf on either side.</span>
        <span class="n">mp_max_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">mp_max_dists</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="n">num_iterations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mp_max_dists</span><span class="p">)</span>

        <span class="n">iterations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_iterations</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># divide by 2 to correct for tile and flatten</span>
        <span class="n">non_inf_max_distances</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">mp_max_dists</span> <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
        <span class="n">max_non_inf</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">non_inf_max_distances</span><span class="p">)</span>
        <span class="n">new_inf_value</span> <span class="o">=</span> <span class="n">max_non_inf</span> <span class="o">*</span> <span class="mf">1.5</span>
        <span class="n">max_distances_replaces_infs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span> <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">else</span> <span class="n">new_inf_value</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mp_max_dists</span><span class="p">])</span>
        <span class="n">inf_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span>
            <span class="n">max_distances_replaces_infs</span> <span class="o">!=</span> <span class="n">new_inf_value</span><span class="p">,</span> <span class="n">max_distances_replaces_infs</span>
        <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="n">max_distances_replaces_infs</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="n">inf_values</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_inf_max_distances</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mp_max_dists</span><span class="p">):</span>
            <span class="n">custom_lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">Line2D</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">4</span><span class="p">)]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">custom_lines</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;infinity&quot;</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Message Passing Convergence&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;iteration&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;log max D_KL(prev_msg||msg)&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_get_unique_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the set of variables in the graph.</span>

<span class="sd">        :return: The variables</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">:</span>
            <span class="n">all_vars</span> <span class="o">+=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">var_names</span>
        <span class="n">unique_vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_vars</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">unique_vars</span>

    <span class="k">def</span> <span class="nf">_get_vars_min_spanning_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the minimum spanning trees of all the variables in the graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_unique_vars</span><span class="p">()</span>
        <span class="n">var_graphs</span> <span class="o">=</span> <span class="p">{</span><span class="n">var</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">all_vars</span><span class="p">}</span>
        <span class="n">num_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_clusters</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_clusters</span><span class="p">):</span>
                <span class="n">sepset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_non_rip_sepsets</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">sepset</span><span class="p">:</span>
                    <span class="n">var_graphs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">var_spanning_trees</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">all_vars</span><span class="p">:</span>
            <span class="n">var_graph</span> <span class="o">=</span> <span class="n">var_graphs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
            <span class="n">var_spanning_trees</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">minimum_spanning_tree</span><span class="p">(</span><span class="n">var_graph</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">var_spanning_trees</span>

    <span class="k">def</span> <span class="nf">_get_running_intersection_sepsets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a set of sepsets for the graph, such that the graph, with these sepsets satisfies the running intersection</span>
<span class="sd">        property.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge_sepset_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">unique_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_unique_vars</span><span class="p">()</span>
        <span class="n">min_span_trees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_vars_min_spanning_trees</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conditional_print</span><span class="p">(</span><span class="s2">&quot;Info: Getting unique variable spanning trees.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_vars</span><span class="p">)),</span> <span class="n">disable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">disable_tqdm</span><span class="p">):</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">unique_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">min_span_tree</span> <span class="o">=</span> <span class="n">min_span_trees</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">min_span_tree</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_sepset_dict</span><span class="p">:</span>
                    <span class="n">edge_sepset_dict</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">edge_sepset_dict</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">edge_sepset_dict</span>

<div class="viewcode-block" id="ClusterGraph.show"><a class="viewcode-back" href="../../veroku.cluster_graph.html#veroku.cluster_graph.ClusterGraph.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Show the cluster graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="s2">&quot;/tmp/test.gv&quot;</span><span class="p">,</span> <span class="n">view</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">IPython</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="s2">&quot;/tmp/test.gv.png&quot;</span><span class="p">)</span>
        <span class="n">IPython</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="n">image</span><span class="p">)</span></div>

<div class="viewcode-block" id="ClusterGraph.save_graph_image"><a class="viewcode-back" href="../../veroku.cluster_graph.html#veroku.cluster_graph.ClusterGraph.save_graph_image">[docs]</a>    <span class="k">def</span> <span class="nf">save_graph_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save image of the graph.</span>

<span class="sd">        :param filename: The filename of the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">graphviz</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;png&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ClusterGraph.get_marginal"><a class="viewcode-back" href="../../veroku.cluster_graph.html#veroku.cluster_graph.ClusterGraph.get_marginal">[docs]</a>    <span class="k">def</span> <span class="nf">get_marginal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vrs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search the graph for a specific variable and get that variables marginal (posterior marginal if process_graph</span>
<span class="sd">        has been run previously).</span>

<span class="sd">        :return: The marginal</span>
<span class="sd">        :rtype: Factor child</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">vrs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">cluster</span><span class="o">.</span><span class="n">var_names</span><span class="p">):</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">factor</span>
                <span class="n">evidence_vrs</span><span class="p">,</span> <span class="n">evidence_values</span> <span class="o">=</span> <span class="n">get_subset_evidence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">special_evidence</span><span class="p">,</span> <span class="n">factor</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">evidence_vrs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">evidence_vrs</span><span class="p">,</span> <span class="n">evidence_values</span><span class="p">)</span>
                <span class="n">marginal</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">marginalize</span><span class="p">(</span><span class="n">vrs</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">marginal</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No cluster with variables containing </span><span class="si">{</span><span class="n">vrs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ClusterGraph.get_posterior_joint"><a class="viewcode-back" href="../../veroku.cluster_graph.html#veroku.cluster_graph.ClusterGraph.get_posterior_joint">[docs]</a>    <span class="k">def</span> <span class="nf">get_posterior_joint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the posterior joint distribution. This function is only intended to be used as a research / debugging tool</span>
<span class="sd">        for small networks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: add functionality for efficiently getting a posterior marginal over any subset of variables and replace</span>
        <span class="c1">#  the get_marginal function above.</span>
        <span class="n">cluster_product</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_factor</span><span class="o">.</span><span class="n">joint_distribution</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">cluster_product</span> <span class="o">=</span> <span class="n">cluster_product</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">cluster</span><span class="o">.</span><span class="n">_factor</span><span class="o">.</span><span class="n">joint_distribution</span><span class="p">)</span>
        <span class="n">last_passed_message_factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_passed_message_factors</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">last_passed_message_factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_messages_passed</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">joint</span> <span class="o">=</span> <span class="n">cluster_product</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message_product</span> <span class="o">=</span> <span class="n">last_passed_message_factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">message_factor</span> <span class="ow">in</span> <span class="n">last_passed_message_factors</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">message_product</span> <span class="o">=</span> <span class="n">message_product</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">message_factor</span><span class="p">)</span>
            <span class="n">joint</span> <span class="o">=</span> <span class="n">cluster_product</span><span class="o">.</span><span class="n">cancel</span><span class="p">(</span><span class="n">message_product</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">joint</span></div>

<div class="viewcode-block" id="ClusterGraph.process_graph"><a class="viewcode-back" href="../../veroku.cluster_graph.html#veroku.cluster_graph.ClusterGraph.process_graph">[docs]</a>    <span class="k">def</span> <span class="nf">process_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">make_animation_gif</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform synchronous message passing until convergence (or maximum iterations).</span>

<span class="sd">        :param tol: The minimum tolerance value for the KL divergence D_KL(previous_message || next_message) that needs</span>
<span class="sd">            to be reached (for all messages) before stopping message passing (before max_iter is reached).</span>
<span class="sd">        :param max_iter: The maximum number of iterations of message passing. The maximum number of messages that can be</span>
<span class="sd">            passed is max_iter * n, where n is the number of message paths (2x the number of edges) in the graph.</span>
<span class="sd">        :param bool make_animation_gif: Whether or not to create an animation of the message passing process when. Note:</span>
<span class="sd">            This can cause slow processing and high memory consumption for large graphs and is therefore recommended to</span>
<span class="sd">            be used only with very small (&gt;50 cluster) graphs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sync_message_passing_max_distances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># The Cluster Graph contains only single cluster. Message passing not possible or necessary.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_evidence</span><span class="p">:</span>
                <span class="n">evidence_vrs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">special_evidence</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">evidence_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">special_evidence</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clusters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_factor</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
                    <span class="n">vrs</span><span class="o">=</span><span class="n">evidence_vrs</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">evidence_values</span>
                <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># TODO: see if the definition of max_iter can be improved</span>
        <span class="n">key_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">next_information_gain</span>
        <span class="n">max_message_passes</span> <span class="o">=</span> <span class="n">max_iter</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key_func</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">max_message_passes</span><span class="p">),</span> <span class="n">disable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">disable_tqdm</span><span class="p">):</span>
            <span class="n">sender_cluster_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sender_cluster</span><span class="o">.</span><span class="n">cluster_id</span>
            <span class="n">receiver_cluster_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">receiver_cluster</span><span class="o">.</span><span class="n">cluster_id</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">passed_messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">next_message</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pass_next_message</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_messages_passed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span>
                <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key_func</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># self.graph_message_paths = _sort_almost_sorted(self.graph_message_paths, key=key_func)</span>

            <span class="n">max_next_information_gain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">next_information_gain</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sync_message_passing_max_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_next_information_gain</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_next_information_gain</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="n">make_animation_gif</span><span class="p">:</span>
                <span class="n">cg_animation</span><span class="o">.</span><span class="n">add_message_pass_animation_frames</span><span class="p">(</span>
                    <span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">,</span>
                    <span class="n">frames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">message_passing_animation_frames</span><span class="p">,</span>
                    <span class="n">node_a_name</span><span class="o">=</span><span class="n">sender_cluster_id</span><span class="p">,</span>
                    <span class="n">node_b_name</span><span class="o">=</span><span class="n">receiver_cluster_id</span><span class="p">,</span>
                <span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_last_passed_message_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The factors of the messages passed in the last iteration of message passing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">gmp</span><span class="o">.</span><span class="n">previously_sent_message</span><span class="o">.</span><span class="n">factor</span> <span class="k">for</span> <span class="n">gmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_message_paths</span><span class="p">]</span>

<div class="viewcode-block" id="ClusterGraph.make_message_passing_animation_gif"><a class="viewcode-back" href="../../veroku.cluster_graph.html#veroku.cluster_graph.ClusterGraph.make_message_passing_animation_gif">[docs]</a>    <span class="k">def</span> <span class="nf">make_message_passing_animation_gif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;graph_animation.gif&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make message passing animation and save a GIF of the animation to file. Note that this function will only work</span>
<span class="sd">        if the make_animation_gif variable was set to True when the process_graph method was called.</span>

<span class="sd">        :param str filename: The name of the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message_passing_animation_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">save</span><span class="p">(</span>
            <span class="n">fp</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;./</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;GIF&quot;</span><span class="p">,</span>
            <span class="n">append_images</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">message_passing_animation_frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
            <span class="n">save_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">duration</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
            <span class="n">loop</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">_GraphMessagePath</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A specific path (direction along an edge) in a graph along which a message can be passed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender_cluster</span><span class="p">,</span> <span class="n">receiver_cluster</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The initializer.</span>

<span class="sd">        :param Cluster sender_cluster: The cluster that defines the starting point of the path.</span>
<span class="sd">        :param Cluster  receiver_cluster: The cluster that defines the end point of the path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sender_cluster</span> <span class="o">=</span> <span class="n">sender_cluster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">receiver_cluster</span> <span class="o">=</span> <span class="n">receiver_cluster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">previously_sent_message</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sender_cluster</span><span class="o">.</span><span class="n">make_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">receiver_cluster</span><span class="o">.</span><span class="n">cluster_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_information_gain</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">information_gains_with_iters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_next_information_gain</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">update_next_information_gain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the information gain that will be achieved when passing the next message.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">previously_sent_message</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next_information_gain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_message</span><span class="o">.</span><span class="n">distance_from_vacuous</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># &quot;In the context of machine learning, KL(P||Q) is often called the information gain achieved if Q is</span>
            <span class="c1"># used instead of P.&quot; - wikipedia</span>
            <span class="c1"># We typically want to know which new message (Q) will result in the largest information gain if it replaces</span>
            <span class="c1"># the message (P)</span>
            <span class="c1"># message: previous_message (P)</span>
            <span class="c1"># factor: next message (Q)</span>
            <span class="c1"># P.kl_divergence(Q)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next_information_gain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">previously_sent_message</span><span class="o">.</span><span class="n">kl_divergence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">next_message</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">information_gains_with_iters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">next_information_gain</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">recompute_next_message</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recompute the next message.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_next_message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sender_cluster</span><span class="o">.</span><span class="n">make_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">receiver_cluster</span><span class="o">.</span><span class="n">cluster_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_message</span> <span class="o">=</span> <span class="n">new_next_message</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_next_information_gain</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">pass_next_message</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pass the next message along this path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">receiver_cluster</span><span class="o">.</span><span class="n">receive_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">next_message</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">previously_sent_message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_message</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_information_gain</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">information_gains_with_iters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">next_information_gain</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">gmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">receiver_cluster</span><span class="o">.</span><span class="n">_outward_message_paths</span><span class="p">:</span>
            <span class="n">gmp</span><span class="o">.</span><span class="n">recompute_next_message</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">veroku</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">veroku</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, EJ Louw.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>